GSL_RNG_SEED=12345
NETWORK INITIALIZATION
PAYMENTS INITIALIZATION
EVENTS INITIALIZATION
INITIAL DIJKSTRA THREADS EXECUTION
Time consumed by initial dijkstra executions: 83 s
EXECUTION OF THE SIMULATION
Time consumed by simulation events: 0.859189 s
cloth.c: Cannot find the output directory. The output will be stored in the current directory.
COMPUTE SIMULATION OUTPUT STATS
Batch length: 158869 ms
Total simulated time: 4766070 ms
SIMULATION OUTPUT STATS SAVED IN <./cloth_output.json>

GSL_RNG_SEED=12345
NETWORK INITIALIZATION
PAYMENTS INITIALIZATION
EVENTS INITIALIZATION
INITIAL DIJKSTRA THREADS EXECUTION
Average Edge Weight: 2948.530886
Total Edge : 168622385
Time consumed by initial dijkstra executions: 77 s
EXECUTION OF THE SIMULATION
Time consumed by simulation events: 0.806436 s
COMPUTE SIMULATION OUTPUT STATS
Batch length: 158869 ms
Total simulated time: 4766070 ms
SIMULATION OUTPUT STATS SAVED IN <outputcloth_output.json>


1 -> payment
nodes  -> fees generate
2 -> routing

struct distance{
  long node;
  uint64_t distance;
  uint64_t amt_to_receive;
  uint64_t fee;
  double probability;
  uint32_t timelock;
  double weight;
  long next_edge;
};

struct event {
  uint64_t time;
  enum event_type type;
  long node_id;
  struct payment *payment;
};

struct simulation{
  uint64_t current_time; //milliseconds
  struct heap* events;
  gsl_rng* random_generator;
};


struct network {
  struct array* nodes;
  struct array* channels;
  struct array* edges;
  gsl_ran_discrete_t* faulty_node_prob; //the probability that a nodes in the network has a fault and goes offline
};

/* an edge represents one of the two direction of a payment channel */
struct edge {
  long id;
  long channel_id;
  long from_node_id;
  long to_node_id;
  long counter_edge_id;
  struct policy policy;
  uint64_t balance;
  unsigned int is_closed;
  uint64_t tot_flows;
};

/* a policy that must be respected when forwarding a payment through an edge (see edge below) */
struct policy {
  uint64_t fee_base;
  uint64_t fee_proportional;
  uint64_t min_htlc;
  uint32_t timelock;
// };